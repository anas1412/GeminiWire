# GeminiWire

## Project Overview

**GeminiWire** is a framework designed to enable users to define, store, and securely execute custom prompts as **wires** (individual functions) and chain them together to create **wireflows** (workflows). The system leverages **Google Gemini API** for AI-powered prompt processing, providing a dynamic and automated way to generate outputs based on user-defined logic. The backend is built using **FastAPI** and **MongoDB**, ensuring scalability, flexibility, and ease of use.

---

## Key Features

1. **Wires**:

   - Reusable functions that take dynamic inputs, process them using a prompt, and generate an output.
   - Each wire has a unique `wire_id`, a `prompt` template, and a schema for inputs (including type, required flag, and description).
   - Supports chaining, where the output of one wire can be used as input for another.

2. **Wireflows**:

   - Sequences of wires executed in a specific order.
   - Each wireflow has a unique `workflow_id`, a description, and a list of wires with their inputs and output keys.

3. **Execution Context**:

   - A dictionary that stores the outputs of wires during the execution of a wireflow.
   - Enables data flow between wires in a workflow.

4. **Database**:

   - Uses **MongoDB** to store wire definitions, wireflows, and execution logs.
   - Provides persistence and efficient querying for managing wires and wireflows.

5. **CRUD Operations**:

   - Full CRUD (Create, Read, Update, Delete) functionality for wires and wireflows.
   - Ensures easy management of wires and wireflows through RESTful APIs.

6. **Error Handling and Logging**:
   - Logs all wire and wireflow executions, including inputs, outputs, and status (success/failure).
   - Provides detailed error messages for debugging and auditing.

---

## Technical Stack

1. **Backend Framework**:

   - **FastAPI**: For building RESTful APIs with asynchronous support.
   - **Pydantic**: For data validation and schema definition.

2. **Database**:

   - **Atlas MongoDB**: A NoSQL database for storing wires, wireflows, and execution logs.
   - **Motor**: An asynchronous MongoDB driver for Python.

3. **AI Integration**:

   - **Google Gemini API**: For processing prompts and generating outputs.

4. **Environment Management**:

   - **Python-dotenv**: For managing environment variables (e.g., API keys, database URI).

5. **Testing**:
   - **Pytest**: For unit and integration testing.

---

## Database Schema

The MongoDB database consists of three collections:

### 1\. **Wires**

Stores the definition of individual wires.

```json
{
  "wire_id": "string", // Unique identifier for the wire
  "description": "string", // Brief description of the wire
  "prompt": "string", // Prompt template for generating output
  "inputs": {
    // Dictionary of input parameters
    "input_key": {
      "type": "string", // Data type of the input (e.g., string, integer)
      "required": "boolean", // Whether the input is mandatory
      "description": "string" // Description of the input
    }
  },
  "chaining": {
    // Chaining configuration
    "allowed": "boolean", // Whether chaining is allowed
    "output_key": "string" // Key for storing the output in the execution context
  }
}
```

### 2\. **Wireflows**

Stores the definition of wireflows.

```json
{
  "workflow_id": "string", // Unique identifier for the wireflow
  "description": "string", // Brief description of the wireflow
  "wires": [
    // List of wires in the workflow
    {
      "wire_id": "string", // ID of the wire to execute
      "inputs": {
        // Inputs for the wire
        "input_key": "string" // Can be a static value or a reference to a previous output (e.g., "$output_key")
      },
      "output_key": "string" // Key for storing the output in the execution context
    }
  ]
}
```

### 3\. **Execution Logs**

Logs the execution of wires and wireflows.

```json
{
  "wire_id": "string", // ID of the wire executed (if applicable)
  "workflow_id": "string", // ID of the wireflow executed (if applicable)
  "inputs": {
    // Inputs used for execution
    "input_key": "string"
  },
  "outputs": "string", // Output generated by the wire
  "status": "string", // Status of execution (SUCCESS/FAILURE)
  "error_message": "string", // Error message (if execution failed)
  "executed_at": "datetime" // Timestamp of execution
}
```

---

## API Endpoints

### 1\. **Wires**

- **POST /wires**: Create a new wire.

- **GET /wires/{wire_id}**: Retrieve a wire by ID.

- **PUT /wires/{wire_id}**: Update a wire by ID.

- **DELETE /wires/{wire_id}**: Delete a wire by ID.

### 2\. **Wireflows**

- **POST /wireflows**: Create a new wireflow.

- **GET /wireflows/{workflow_id}**: Retrieve a wireflow by ID.

- **PUT /wireflows/{workflow_id}**: Update a wireflow by ID.

- **DELETE /wireflows/{workflow_id}**: Delete a wireflow by ID.

### 3\. **Execution**

- **POST /execute/wire**: Execute a single wire.

- **POST /execute/wireflow**: Execute a wireflow.

---

## Execution Flow

### 1\. **Wire Execution**

- Fetch the wire definition from the database.

- Validate the inputs against the wire's input schema.

- Format the prompt using the provided inputs.

- Call the Google Gemini API to generate the output.

- Log the execution and return the output.

### 2\. **Wireflow Execution**

- Fetch the wireflow definition from the database.

- Initialize an empty execution context.

- For each wire in the wireflow:

  - Prepare the inputs by replacing placeholders with values from the execution context.

  - Execute the wire and store the output in the execution context.

- Return the final execution context.

---

## Error Handling

1.  **Validation Errors**:

    - Missing or invalid inputs are flagged with a `400 Bad Request` response.

2.  **Execution Errors**:

    - Errors during wire or wireflow execution are logged and returned with a `500 Internal Server Error` response.

3.  **Not Found Errors**:

    - Missing wires or wireflows are flagged with a `404 Not Found` response.

---

## Testing

1.  **Unit Tests**:

    - Test individual components (e.g., wire execution, input validation).

2.  **Integration Tests**:

    - Test the end-to-end flow of wire and wireflow execution.

3.  **Tools**:

    - **Pytest**: For writing and running tests.

    - **Postman**: For manual API testing.

---

## Deployment

1.  **Backend**:

    - Containerize the FastAPI app using **Docker**.

    - Deploy to **Heroku**, **AWS**, or any other cloud platform.

2.  **Database**:

    - Use a managed MongoDB service like **MongoDB Atlas** or **AWS DocumentDB**.

3.  **Environment Variables**:

    - Store sensitive data (e.g., API keys, database URI) in `.env`.

---

## Future Enhancements

1.  **Authentication**:

    - Add user authentication to secure wire and wireflow execution.

2.  **Workflow Management**:

    - Allow users to define and manage complex workflows with conditional logic.

3.  **UI Integration**:

    - Build a React frontend for a user-friendly interface.

4.  **Error Handling**:

    - Improve error handling and provide detailed error messages to users.

---

## Conclusion

**GeminiWire** is a robust and scalable framework for managing AI-powered workflows. The backend, built with **FastAPI** and **MongoDB**, provides a flexible and efficient solution for defining, executing, and managing wires and wireflows. The project adheres to best practices, ensuring clean code, modular design, and ease of maintenance.
